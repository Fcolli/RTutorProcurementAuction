if (belief[1]==1){
x=cost+(100-cost-25)/2;
}
if (belief[2]==1){
if (cost==55){
x=100; # kein trade
}else{
x=cost+max(0,abs(100-o.opp[t]-o.own[t]));;
}
}
return(list(x=x,o.own=o.own,o.opp=o.opp,belief=belief))
}
# neuer Versuch mit belief nach Kosten des Gegners
versuch1 = function(obs,i,t,o.own=c(0),o.opp=c(0),belief=c(0,0),...) {
# Extract variables from obs
cost = obs$cost;
j = 3-i;
o.own[t]=obs$x[i];
o.opp[t]=obs$x[j];
# belief[1]=belief nach kosten des Geners sind 25, belief[2]=belief nach kosten des Geners sind 55
# Ansatz: Falls Kosten von (i,j)==(25,25) sollte der Gewinn gegen 25 konvergieren. Falls (55,55) kein Handel.
# Falls (i,j)=(25,55) sollte mein gewinn gegen (100-25-55)*(55/(25+55))=13.75 konvergierne. Falls (55,25) nach 20*(25/(80))=6.25
if (t==1){
if (cost==55){
x=cost+5+0.141119891;
}else{
x=cost+14+0.141119891;
}
}
if (t>=2){
if (o.opp[2]==floor(o.opp[2])+0.141119891){
x=cost;
return(list(x=x,o.own=o.own,o.opp=o.opp,belief=belief))
}
if (min(o.opp[2:t])<55){
# was wenn einer vorgibt geringere kosten zu haben
belief[1]=1;
}else{
# muss man noch verbessern
belief[2]=1;
}
}
if (belief[1]==1){
x=cost+(100-cost-25)/2;
}
if (belief[2]==1){
if (cost==55){
x=100; # kein trade
}else{
x=cost+max(0,abs(100-o.opp[t]-o.own[t]));;
}
}
return(list(x=x,o.own=o.own,o.opp=o.opp,belief=belief))
}
versuch1 = function(obs,i,t,o.own=c(0),o.opp=c(0),belief=c(0,0),d=0.9,...) {
# Extract variables from obs
cost = obs$cost
j = 3-i
o.own[t]=obs$x[i]
o.opp[t]=obs$x[j]
# belief[1]=belief nach kosten des Geners sind 25, belief[2]=belief nach kosten des Geners sind 55
# Ansatz: Falls Kosten von (i,j)==(25,25) sollte der Gewinn gegen 25 konvergieren. Falls (55,55) kein Handel.
# Falls (i,j)=(25,55) sollte mein gewinn gegen (100-25-55)*(55/(25+55))=13.75 konvergierne. Falls (55,25) nach 20*(25/(80))=6.25
if (t==1){
if (cost==55){
x=cost+5+0.141119891
}else{
x=cost+14+0.141119891
}
}
if (t>=2){
if (o.opp[2]==floor(o.opp[2])+0.141119891){
x=cost
return(list(x=x,o.own=o.own,o.opp=o.opp,belief=belief,d=d))
}
if (min(o.opp[2:t])<55){
# was wenn einer vorgibt geringere kosten zu haben
belief[1]=1
}else{
# muss man noch verbessern
belief[2]=1
}
}
if (belief[1]==1){
if (cost==25){
x=cost+25*d
}else{
x=cost+10*d
}
}
if (belief[2]==1){
if (cost==55){
x=cost+1 # kein trade
}else{
x=cost+10*d
}
}
return(list(x=x,o.own=o.own,o.opp=o.opp,belief=belief,d=d))
}
install.packages("tidyr")
library(devtools)
library(StratTourn)
if (!require(devtools))
install.packages("devtools")
source_gist("gist.github.com/skranz/fad6062e5462c9d0efe4")
install.rtutor(update.github=TRUE)
install_github("JonasSend/RTutorTopIncomeTaxation")
library(RTutorTopIncomeTaxation)
# Adapt your working directory to an existing folder
setwd("C:/Users/Freddy/Desktop/Problemset")
# Adapt your user name
run.ps(user.name="Jon Doe", package="RTutorTopIncomeTaxation")
library("RTutor", lib.loc="C:/Program Files/R/R-3.2.0/library")
remove.packages("RTutor")
T=1000
b0=10
b1=2
b2=3
x2=runif(T,0,5)
x1=x2+runif(T,-0.5,0.5)
y=b0+b1*x1+b2+x2+rnorm(T,0,1)
reg1=lm(y~x1)
reg2=lm(y~x1+x2)
reg3=lm(x2~x1)
bshort=coefficient(reg1)
bshort=coefficients(reg1)
bshort=coefficients(reg1)
btrue=coefficients(reg2)
a=coefficients(reg3)
bshort
btrue
a
(2.999-2.022)/(1.019)
(0.76-0.37)/0.81
x1=1:100
y=log(1:100)
lm(y~x)
lm(y~x1)
log(1:10)
T=1000
b0=10
b1=2
b2=3
x2=runif(T,0,5)
x1=x2+runif(T,-0.5,0.5)
y=b0+b1*x1+b2+x2+rnorm(T,0,1)
reg1=lm(y~x1)
reg2=lm(y~x1+x2)
reg3=lm(x2~x1)
bshort=coefficients(reg1)
btrue=coefficients(reg2)
a=coefficients(reg3)
instr=runif(T,0,10)
x1=instr*0.5 +runif(T,-0.5,0.5)
y=b0+b1*instr
reg1=lm(y~x1)
summary(reg1)
library(AER)
reg2=ivreg(y~x1|iv)
reg2=ivreg(y~x1|instr)
summary(reg2)
cor(iv,x1)
cor(instr,x1)
cor(instr,y)
y=b0+b1*instr+rnorm(T,0,1)
reg1=lm(y~x1)
summary(reg1)
library(AER)
reg2=ivreg(y~x1|instr)
summary(reg2)
instr=runif(T,0,10)
x1=instr*0.5 +runif(T,-0.5,0.5)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
T=1000
b0=10
b1=2
b2=3
# x2=runif(T,0,5)
# x1=x2+runif(T,-0.5,0.5)
# y=b0+b1*x1+b2+x2+rnorm(T,0,1)
# reg1=lm(y~x1)
# reg2=lm(y~x1+x2)
# reg3=lm(x2~x1)
# bshort=coefficients(reg1)
# btrue=coefficients(reg2)
# a=coefficients(reg3)
instr=runif(T,0,10)
x1=instr*0.5 +runif(T,-0.5,0.5)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
summary(reg1)
library(AER)
reg2=ivreg(y~x1|instr)
summary(reg2)
residuals(reg2)
plot(residuals(reg2),y)
plot(residuals(reg1),y)
x1=runif(T,-2,8)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
r=residuals(reg1)
plot(r,y)
plot(r,x1)
plot(x1,r)
length((T/2):T)
length((T/2)+1:T)
length(((T/2)+1):T)
x1=runif(T,-2,8)
x1[((T/2)+1):T]=rnorm(T/2,10,3)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
r=residuals(reg1)
plot(x1,r)
x1=runif(T,-2,8)
x1[((T/2)+1):T]=rnorm(T/2,20,7)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
r=residuals(reg1)
plot(x1,r)
x1[((T/2)+1):T]=rnorm(T/2,5,100)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
r=residuals(reg1)
plot(x1,r)
x1[((T/2)+1):T]=rnorm(T/2,5,10)
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
r=residuals(reg1)
plot(x1,r)
x1=runif(T,-2,8)
x1[((T/2)+1):T]=x1[((T/2)+1):T]*5
y=b0+b1*x1+rnorm(T,0,1)
reg1=lm(y~x1)
r=residuals(reg1)
plot(x1,r)
X=runif(T,0,5)
T=100
t=5
X=runif(T,0,t)
ml=max(X)
mm=mean(X)*2
ml=c(0)
mm=c(0)
Ti=c(0)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,ml)
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
ml=c(0)
mm=c(0)
Ti=c(0)
for (i in 1:100){
T=10*i
t=5
X=runif(T,0,t)
ml[i]=max(X)
mm[i]=mean(X)*2
Ti[i]=T
}
plot(Ti,mm)
plot(Ti,ml)
plot(Ti,ml-mm)
mean(mm)
mean(ml)
plot(Ti,mm)
0.0165/0.249
0.636*1.366
0.544-0.868
(20/18)*(sqrt(109/100)-1)
(20/18)*(sqrt(181/100)-1)
x=seq(from=0.01,to=1,length.out=100)
sqrt(724)
sqrt(884)
-20
(sqrt(884)-20)/22
---
output:
html_document:
highlight: textmate
theme: readable
toc: yes
---
Analyzing Cooperation with Game Theory and Simulation
========================================================================
Task Set 2: Noisy Prisoner Dilemma
========================================================================
**Date: 2014-10-12**
**Author: Sebastian Kranz (sebastian.kranz@uni-ulm.de)**
**with contibutions by**
**Martin Kies (martin.kies@uni-ulm.de) and**
**Daniel Blochinger (daniel.blochinger@uni-ulm.de)**
Please install for this task the newest Version of StratTourn
```{r, include=FALSE}
library(devtools)
install_github(repo="skranz/StratTourn")
net.coop = function(obs,i,t, times.coop=c(0,0), ...) {
debug.store("net.coop",i,t) # Store each call for each player
debug.restore("net.coop",i=1,t=2) # Restore call for player i in period t
if (t==1) {
return(list(a="C",times.coop=times.coop))
}
j = 3-i
# Update how many times i and j were observed(!)
# to cooperate in total
times.coop    = times.coop + (obs$a=="C")
# Cooperate if and only if in total player j
# was observed cooperating as least as often as i
if (times.coop[i] <= times.coop[j]) {
a="C"
} else {
a="D"
}
return(list(a=a,times.coop=times.coop))
}
### Task 2.1 Invading with a better strategy
We consider the noisy prisoners' dilemma game from Task 1, Scenario 1. Consider a population in which initially 98% of the inhabitants play the following `net.coop`strategy:
```{r}
net.coop = function(obs,i,t, times.coop=c(0,0), ...) {
debug.store("net.coop",i,t) # Store each call for each player
debug.restore("net.coop",i=1,t=2) # Restore call for player i in period t
if (t==1) {
return(list(a="C",times.coop=times.coop))
}
j = 3-i
# Update how many times i and j were observed(!)
# to cooperate in total
times.coop    = times.coop + (obs$a=="C")
# Cooperate if and only if in total player j
# was observed cooperating as least as often as i
if (times.coop[i] <= times.coop[j]) {
a="C"
} else {
a="D"
}
return(list(a=a,times.coop=times.coop))
}
```
Another 1% of the population initially plays `always.defect`:
```{r}
# A strategy that always defects
always.defect = function(obs,i,t,...) {
return(list(a="D"))
}
```
Your goal is to develop a strategy that starts with initially only 1% of the population and after an evolutionary process becomes succesful in terms of payoffs and share of population that follows it.
We consider the following evolutionary process:
- 500 generations
- alpha = 1
- minimum shares of each strategy = 0.1%
Your score is the sum of the share and average payoff of your strategy at the end of this evolutionary dynamic.
- On the Moodle site of the seminar, you find a file **coop2_template.Rmd**, which you can download and open in RStudio. You should insert your solutions and a description of your strategy and how you have developed it in that file. Send your solution to
martin.kies@uni-ulm.de
until **Thursday 27.11.2014**.
### A code example for testing strategies
```{r include=FALSE}
library(StratTourn)
set.storing(FALSE)
runif(1)
```
```{r eval=FALSE, cache=FALSE}
library(StratTourn)
# parameters from scenario 1
err.D.prob = 0.25; delta = 0.985
game = make.pd.game(err.D.prob=err.D.prob, delta=delta)
library(StratTourn)
library(devtools)
install_github(repo="skranz/StratTourn")
library(StratTourn)
game = make.pd.game(err.D.prob=0.15)
strat = nlist(always.coop,erstertest)
run.rep.game(delta=0.9, game=game, strat=strat)
err.D.prob = 0.25; delta = 0.985
game = make.pd.game(err.D.prob=err.D.prob, delta=delta)
strat = nlist(tit.for.tat,random.action)
run.rep.game(game=game, strat = strat)
setwd("C:/Users/Freddy/Documents")
strat = nlist(tit.for.tat,erstertest, always.coop)
tourn = init.tournament(game=game, strat=strat)
set.storing(FALSE) # makes code faster, but harder to debug
tourn = run.tournament(tourn=tourn, R = 10)
set.storing(TRUE)
tourn
shares = get.evolutionary.shares(tourn, generations=100, alpha=0.25, min.shares = 1/1000)
show.tournament(tourn, strat.shares=shares)
library(devtools)
install_github(repo="skranz/StratTourn")
devtools::install_github("rstudio/rmarkdown")
devtools::install_github("skranz/rmarkdown")
rmarkdown::render('in.md',
output_format=pdf_document(latex_engine='xelatex')
)
rmarkdown::render('in.md',output_format=pdf_document(latex_engine='xelatex'))
options(scipen=999)
getwd()
setwd("C:/problemsets/RTutorProcurementAuction")
setwd("C:/Users/Freddy/Desktop/MasterarbeitGitHub/RTutorProcurementAuction")
run.ps(user.name="Jon Doe", package="RTutorProcurementAuction",
load.sav=TRUE, sample.solution=FALSE)
library(RTutor)
run.ps(user.name="Jon Doe", package="RTutorProcurementAuction",
load.sav=TRUE, sample.solution=FALSE)
library(RTutorProcurementAuction)
